---
title: "2023 Mar 07"
date: 2023-03-26T21:11:39-05:00
draft: false
---

- [References vs. pointers in Rust](https://stackoverflow.com/questions/62232753/what-are-the-differences-between-a-pointer-and-a-reference-in-rust), [Rust docs on pointer primitive](https://doc.rust-lang.org/std/primitive.pointer.html). I’d seen `*const` before but never really looked into it. This is a raw pointer in rust, and if you want to dereference it, you have to use an unsafe block, as the compiler cannot know for certain whether it will be null or not. Null actually exists in Rust for these raw pointers! It seems raw pointers are only really used for FFIs and/or working with libc, or maybe some very specific memory management I can’t think of an example for.

- A question I’ve always had: why can’t you have variable sized arrays on the stack? Apparently it’s just a safeguard built into programming languages to avoid stack overflow. The stack is much smaller than the heap, and variable sized arrays risk using too much of the stack. I’m sort of surprised this is a thing. C will let you do very dangerous things, but it won’t let you allocate a variable sized array on the stack. I guess you could hack it with pointers and put data in contiguous memory addresses, but dang. I can even imagine that there could be many programs that might have a small variable sized arrays that would definitely fit on the stack, but those aren’t possible (elegantly) I guess.
- Also apparently stack size is usually just set to a megabyte, and determining how much stack space is required for a program [is very hard in the general case](https://stackoverflow.com/questions/1756285/stack-size-estimation). Some people will try and fill the stack with dummy values and run the program and see if it overflows. Apparently programs usually overshoot the stack size, but it’s not too harmful to do that. Except in embedded systems it gets complicated. [Programmers can set the stack size](https://stackoverflow.com/questions/22047121/how-does-the-operating-system-determine-how-much-stack-space-should-be-allotted) too, and apparently [the concept of the stack and heap growing towards each other is a myth](https://stackoverflow.com/questions/12687274/size-of-stack-and-heap-memory). The heap is not just much bigger than the stack, it can dynamically grow in size, meaning a program’s total memory usage is not statically allocated. I remember learning a lot of this in our systems programming class, but need to refresh specifics.
- Wish I could take CS 241 again, that class had so much good stuff in it. [Coursebook](https://github.com/illinois-cs241/coursebook) - pretty funny, the introduction includes a couple paragraphs on editors and the TA who wrote a section that includes he uses spacemacs lol. Unfortunately the [course site](https://cs241.cs.illinois.edu/) seems to be down right now…(or I think I need to be on the school VPN)
- Note: they uploaded [example proposals from last year](https://guide.summerofbitcoin.org/the-proposal-round/writing-a-good-project-proposal#example-proposals-authored-by-past-summer-of-bitcoin-students) for Summer of Bitcoin
- Thinking about inflation again. We might only perceive inflation in terms of how much our money is worth relative to the rise in prices of goods we typically buy, but this doesn’t account for the improvements in production. Over long periods, we don’t realize this inflation is *on top* of however much cheaper these goods have become to produce. Say we see a 10% increase in prices, but this good actually became cheaper to produce which would’ve decreased the initial price by 20%, so our money has actually inflated 37.5% when we only think it’s inflated 10%!
- Mainly was working on adding a test to [this PR](https://github.com/lightningdevkit/rust-lightning/pull/2062) today. Modified an update_add_htlc message by reconstructing an onion to modify its values to overshoot amt_to_forward to check that we use the onion value for MPP set calculation.

